# Send UDP broadcast packets

import socket
import socketserver
import time
import json
from SharedVars import tt

MYPORT = 50000
MYPORT2 = 50001

global server_address
server_address = ('', 0)
global connected
connected = []


def parse_message(data):
    recieve_time = time.time()

    message = data[0].decode('utf-8')
    address = data[1]
    if message != 'scan':
        if not is_repeat(message, address, recieve_time):
            # Only prints messages from other computers
            if address[0] != socket.gethostbyname(socket.gethostname()):
                print('Message: ' + message + '\nAddress: ' + address[0])

            # Message Parsing
            if message == 'connecting':
                try:
                    tt.connectedIPs.index(address[0])
                except ValueError:
                    tt.threatData[address[0]] = []
                    tt.connectedIPs.append(address[0])
                send_message("Request Threats".encode('utf-8'), address)

            elif message == 'Request Threats':
                print("sending threats")
                send_message(json.dumps(['Threats:'].append(tt.threatList)).encode('utf-8'), address)
                print("sent threats")

            elif message.split(' ')[0] == '[Threats: ':
                tt.threatData[address[0]] = json.loads(message)[1:]
                print(tt.threatData)
                for x in connected:
                    if x != address:
                        send_message(message, x)

            elif message == 'disconnecting':
                connected.remove(address)
                for x in connected:
                    send_message('disconnected' + address, address)

            elif message.split(' ')[0] == 'disconnected':
                return

            elif message.split(' ')[0] == ':':
                return

            else:
                return
        else:
            return


def send_message(data, address):
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    last = time.time()
    while time.time() - last < .2:
        s.sendto(data, address)


def is_repeat(data, address, time_received):
    to_delete = []

    for x in tt.recent_messages:
        if time_received - x['time'] < .2:
            if data == x['message'] and address == x['address']:
                return True
        else:
            to_delete.append(x)

    tt.recent_messages.append({'message': data, 'address': address, 'time': time_received})

    for x in to_delete:
        tt.recent_messages.remove(x)

    return False


def broadcast_server():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.bind(('', MYPORT))
    s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    s.setblocking(0)

    sTCP = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sTCP.bind(('', MYPORT2))
    sTCP.setblocking(0)
    sTCP.settimeout(1)
    print("Server Initialized.")
    last = time.time()

    while True:
        # Sending first contact message via UDP socket
        data = bytes("scan".encode(encoding='utf-8'))
        if time.time() - last > .001:
            try:
                s.sendto(data, ('255.255.255.255', MYPORT))
            except socket.error:
                pass

        try:
            m = s.recvfrom(1024)
            parse_message(m)
        except socket.error:
            pass

        last = time.time()

        # try:
        #    conn, addr = sTCP.accept()
        #    sTCP.sendto("recieved", conn)
        #    connected.append(conn)
        #    print(addr)
        #    print(conn)
        #    print(connected)
        # except socket.error:
        #    pass


def broadcast_client():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.bind(('', MYPORT))
    s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    s.setblocking(0)

    while True:
        try:
            m = s.recvfrom(1024)
            parse_message(m)
        except socket.error:
            pass

#class TCPHandler(socketserver.BaseRequestHandler):
#    def handle(self):
#        from GUI import tt
#        message = self.request.recv(1024).strip()
#       address = self.client_address
#
#   # Only prints messages from other computers
#       if address[0] != socket.gethostbyname(socket.gethostname()):
#           print('Message: ' + message + '\nAddress: ' + address[0])
#
#   # Message Parsing
#       if message == 'connecting':
#           try:
#               tt.connectedIPs[address[0]]
#           except KeyError:
#               tt.threatData[address[0]] = []
 #              tt.connectedIPs.append(address[0])
 #          send_message("Request Threats".encode('utf-8'), address)
#
#        elif message == 'Request Threats':
#            send_message(tt.threatList.encode('utf-8'), address)#
#
#        elif message.split(' ')[0] == 'Threats from:':
#            for x in connected:
#                if x != address:
#                    send_message(message, x)#
#
#        elif message == 'disconnecting':
#            connected.remove(address)
#            for x in connected:
#                send_message('disconnected' + address, address)
#
#        elif message.split(' ')[0] == 'disconnected':
#            return
#
 #       elif message.split(' ')[0] == ':':
 #           return

#        else:
 #           return
